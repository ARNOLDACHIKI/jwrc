{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file:///home/lod/Downloads/jwrc/app/api/events/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\"\nimport { PrismaClient } from \"@prisma/client\"\nimport jwt from \"jsonwebtoken\"\n\nconst prisma = new PrismaClient()\n\nfunction getTokenFromHeaders(req: Request) {\n  const cookie = req.headers.get(\"cookie\") || \"\"\n  const match = cookie.split(\";\").map((c) => c.trim()).find((c) => c.startsWith(\"token=\"))\n  if (!match) return null\n  return match.split(\"=\")[1]\n}\n\nexport async function GET(req: Request) {\n  try {\n    const url = new URL(req.url)\n    const page = Math.max(1, parseInt(url.searchParams.get('page') || '1', 10))\n    const pageSize = Math.max(1, Math.min(50, parseInt(url.searchParams.get('pageSize') || '10', 10)))\n    const futureOnly = url.searchParams.get('futureOnly') === 'true'\n\n    const where: any = {}\n    if (futureOnly) {\n      where.startsAt = { gte: new Date() }\n    }\n\n    const total = await prisma.event.count({ where })\n    const items = await prisma.event.findMany({\n      where,\n      orderBy: { startsAt: 'asc' },\n      skip: (page - 1) * pageSize,\n      take: pageSize,\n    })\n\n    return NextResponse.json({ events: items, total, page, pageSize })\n  } catch (err) {\n    return NextResponse.json({ error: 'Failed to fetch events' }, { status: 500 })\n  }\n}\n\nexport async function POST(req: Request) {\n  try {\n    const token = getTokenFromHeaders(req)\n    const secret = process.env.JWT_SECRET || 'dev-secret'\n    if (!token) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    let payload: any = null\n    try {\n      payload = jwt.verify(token, secret)\n    } catch (e) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    if (payload.role !== 'admin') return NextResponse.json({ error: 'Forbidden' }, { status: 403 })\n\n    const body = await req.json()\n    const { title, description, location, startsAt, endsAt } = body || {}\n    const errors: Record<string, string> = {}\n    if (!title || String(title).trim().length === 0) errors.title = 'Title is required'\n    if (!startsAt) errors.startsAt = 'Start date/time is required'\n\n    let parsedStarts: Date | null = null\n    let parsedEnds: Date | null = null\n    if (startsAt) {\n      const p = Date.parse(startsAt)\n      if (isNaN(p)) errors.startsAt = 'Start date/time is invalid'\n      else parsedStarts = new Date(p)\n    }\n    if (endsAt) {\n      const p2 = Date.parse(endsAt)\n      if (isNaN(p2)) errors.endsAt = 'End date/time is invalid'\n      else parsedEnds = new Date(p2)\n    }\n\n    if (parsedStarts && parsedEnds && parsedEnds < parsedStarts) errors.endsAt = 'End must be after start'\n\n    if (Object.keys(errors).length > 0) {\n      return NextResponse.json({ errors }, { status: 400 })\n    }\n\n    const created = await prisma.event.create({\n      data: {\n        title: String(title),\n        description: description || '',\n        location: location || '',\n        startsAt: parsedStarts as Date,\n        endsAt: parsedEnds || null,\n      },\n    })\n    return NextResponse.json({ event: created }, { status: 201 })\n  } catch (err) {\n    return NextResponse.json({ error: 'Server error' }, { status: 500 })\n  }\n}\n\nexport async function DELETE(req: Request) {\n  try {\n    const token = getTokenFromHeaders(req)\n    const secret = process.env.JWT_SECRET || 'dev-secret'\n    if (!token) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    let payload: any = null\n    try {\n      payload = jwt.verify(token, secret)\n    } catch (e) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })\n    }\n    if (payload.role !== 'admin') return NextResponse.json({ error: 'Forbidden' }, { status: 403 })\n\n    const body = await req.json()\n    const { id } = body || {}\n    if (!id) return NextResponse.json({ error: 'Missing id' }, { status: 400 })\n\n    try {\n      const deleted = await prisma.event.delete({ where: { id } })\n      return NextResponse.json({ deleted })\n    } catch (e: any) {\n      if (e.code === 'P2025') {\n        return NextResponse.json({ error: 'Not found' }, { status: 404 })\n      }\n      return NextResponse.json({ error: 'Failed to delete' }, { status: 500 })\n    }\n  } catch (err) {\n    return NextResponse.json({ error: 'Server error' }, { status: 500 })\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}